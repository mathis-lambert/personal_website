name: CD

on:
  push:
    tags: ["v*", "v*.*", "v*.*.*"]

permissions:
  contents: read

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  docker:
    name: Build and Publish Images
    runs-on: ubuntu-latest
    environment:
      name: PROD
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup QEMU (amd64 + arm64)
        uses: docker/setup-qemu-action@v3

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta (frontend)
        id: meta_frontend
        uses: docker/metadata-action@v5
        with:
          images: |
            ghcr.io/${{ github.repository_owner }}/personal-website-frontend
          tags: |
            # Use the exact pushed tag (e.g., v1.2.3)
            type=ref,event=tag

      - name: Build and push (frontend)
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: frontend/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            VITE_API_URL=${{ vars.VITE_API_URL }}
            VITE_MAINTENANCE_MODE=${{ vars.VITE_MAINTENANCE_MODE }}
            VITE_MAPS_PUBLIC_KEY=${{ vars.VITE_MAPS_PUBLIC_KEY }}
            VITE_APP_VERSION= ${{ github.ref_name }}
          tags: ${{ steps.meta_frontend.outputs.tags }}
          labels: ${{ steps.meta_frontend.outputs.labels }}
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend

      - name: Docker meta (backend)
        id: meta_backend
        uses: docker/metadata-action@v5
        with:
          images: |
            ghcr.io/${{ github.repository_owner }}/personal-website-backend
          tags: |
            # Use the exact pushed tag (e.g., v1.2.3)
            type=ref,event=tag

      - name: Build and push (backend)
        uses: docker/build-push-action@v6
        with:
          context: ./backend
          file: backend/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta_backend.outputs.tags }}
          labels: ${{ steps.meta_backend.outputs.labels }}
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend

  deploy:
    name: Deploy to Raspberry Pi
    needs: [docker]
    runs-on: ubuntu-latest
    environment:
      name: PROD
      url: https://mathislambert.fr
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Upload compose file to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.ML_DEPLOY_HOST }}
          username: ${{ secrets.ML_DEPLOY_USER }}
          key: ${{ secrets.ML_DEPLOY_KEY }}
          port: ${{ secrets.ML_DEPLOY_PORT }}
          source: |
            compose.prod.yaml
          target: "/opt/mathislambert.fr/applications/personal_website"

      - name: Remote deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        env:
          # Backend runtime env (secrets kept in PROD environment)
          MONGODB_HOST: ${{ vars.MONGODB_HOST }}
          MONGODB_PORT: ${{ vars.MONGODB_PORT }}
          MONGODB_USERNAME: ${{ secrets.MONGODB_USERNAME }}
          MONGODB_PASSWORD: ${{ secrets.MONGODB_PASSWORD }}
          MONGODB_DATABASE: ${{ secrets.MONGODB_DATABASE }}
          ML_API_KEY: ${{ secrets.ML_API_KEY }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          JWT_EXPIRE_SECONDS: ${{ vars.JWT_EXPIRE_SECONDS }}
          ADMIN_TOKEN_EXPIRE_SECONDS: ${{ vars.ADMIN_TOKEN_EXPIRE_SECONDS }}
          TOKEN_AUDIENCE: ${{ vars.TOKEN_AUDIENCE }}
          ALLOWED_ORIGINS: ${{ vars.ALLOWED_ORIGINS }}
          LLM_MODEL_NAME: ${{ vars.LLM_MODEL_NAME }}
          INTERNAL_API_USERNAME: ${{ secrets.INTERNAL_API_USERNAME }}
          INTERNAL_API_PASSWORD: ${{ secrets.INTERNAL_API_PASSWORD }}
          MAINTENANCE_MODE: ${{ vars.MAINTENANCE_MODE }}
          POPULATE_MONGODB: ${{ vars.POPULATE_MONGODB }}
        with:
          host: ${{ secrets.ML_DEPLOY_HOST }}
          username: ${{ secrets.ML_DEPLOY_USER }}
          key: ${{ secrets.ML_DEPLOY_KEY }}
          port: ${{ secrets.ML_DEPLOY_PORT }}
          script_stop: true
          envs: GITHUB_REF_NAME,MONGODB_HOST,MONGODB_PORT,MONGODB_USERNAME,MONGODB_PASSWORD,MONGODB_DATABASE,ML_API_KEY,JWT_SECRET_KEY,JWT_EXPIRE_SECONDS,ADMIN_TOKEN_EXPIRE_SECONDS,TOKEN_AUDIENCE,ALLOWED_ORIGINS,LLM_MODEL_NAME,INTERNAL_API_USERNAME,INTERNAL_API_PASSWORD,MAINTENANCE_MODE,POPULATE_MONGODB
          script: |
            set -euo pipefail
            OWNER='${{ github.repository_owner }}'
            TAG="$GITHUB_REF_NAME"  # e.g., v1.2.3
            INSTALL_DIR=/opt/mathislambert.fr/applications/personal_website
            OWNER_LC=$(printf '%s' "$OWNER" | tr '[:upper:]' '[:lower:]')

            # Ensure directories and networks exist
            docker network create proxy || true
            docker network create databases || true
            docker network create monitor || true

            # Login to GHCR (requires a PAT with read:packages) if provided
            if [ -n '${{ secrets.GHCR_TOKEN }}' ]; then
              printf '%s' '${{ secrets.GHCR_TOKEN }}' | docker login ghcr.io -u '${{ secrets.GHCR_USERNAME || github.actor }}' --password-stdin
            fi

            cd "$INSTALL_DIR"
            # Pull and start the updated stack using the tag that triggered this workflow
            OWNER="$OWNER_LC" IMAGE_TAG="$TAG" docker compose -f compose.prod.yaml pull
            OWNER="$OWNER_LC" IMAGE_TAG="$TAG" docker compose -f compose.prod.yaml up -d --remove-orphans

            # Optional cleanup
            docker image prune -f || true
